; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
PUBLIC	printf
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0JI@GFKDDBPG@znakow?3?5?$CFd?6liter?3?5?$CFd?6cyfr?3?5?$CFd?6wy@ ; `string'
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_getchar:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	_RTC_UninitUse:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+182
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN36
	DD	imagerel $LN36+979
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0JI@GFKDDBPG@znakow?3?5?$CFd?6liter?3?5?$CFd?6cyfr?3?5?$CFd?6wy@
CONST	SEGMENT
??_C@_0JI@GFKDDBPG@znakow?3?5?$CFd?6liter?3?5?$CFd?6cyfr?3?5?$CFd?6wy@ DB 'z'
	DB	'nakow: %d', 0aH, 'liter: %d', 0aH, 'cyfr: %d', 0aH, 'wyrazow:'
	DB	' %d', 0aH, 'bialych znakow: %d', 0aH, 'samoglosek: %d', 0aH, 's'
	DB	'polglosek: %d', 0aH, 'duzych liter: %d', 0aH, 'malych liter: '
	DB	'%d', 0aH, 'znakow przestankowych: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	065051e01H
	DD	010a630fH
	DD	07003005dH
	DD	05002H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 077H
	DB	079H
	DB	072H
	DB	061H
	DB	07aH
	DB	00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 025054a19H
	DD	011d2322H
	DD	070160025H
	DD	05015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
printf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
printf$rtcVarDesc DD 048H
	DD	08H
	DQ	FLAT:printf$rtcName$0
	ORG $+48
printf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:printf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ DD 05051c01H
	DD	010a030dH
	DD	070030019H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 035053901H
	DD	011d3322H
	DD	07016001fH
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 05051c01H
	DD	010a030dH
	DD	070030019H
	DD	05002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\lenovo\documents\visual studio 2015\projects\consoleapplication1\consoleapplication1\consoleapplication1.cpp
;	COMDAT main
_TEXT	SEGMENT
prevCh$ = 4
ch$ = 36
znaki$ = 68
litery$ = 100
cyfry$ = 132
wyrazy$ = 164
bZnaki$ = 196
samog$ = 228
spolg$ = 260
DL$ = 292
ml$ = 324
znakiP$ = 356
wyraz$ = 388
$T2 = 612
main	PROC						; COMDAT

; 9    : {

$LN36:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0000a	48 8d 6c 24 60	 lea	 rbp, QWORD PTR [rsp+96]
  0000f	48 8b fc	 mov	 rdi, rsp
  00012	b9 ba 00 00 00	 mov	 ecx, 186		; 000000baH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	c6 85 64 02 00
	00 00		 mov	 BYTE PTR $T2[rbp], 0

; 10   : 	int prevCh = EOF, ch = getchar(), znaki = 0, litery = 0, cyfry = 0, wyrazy = 0, bZnaki = 0, samog = 0, spolg = 0, DL = 0, ml = 0, znakiP = 0, wyraz;

  00025	c7 45 04 ff ff
	ff ff		 mov	 DWORD PTR prevCh$[rbp], -1
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getchar
  00032	89 45 24	 mov	 DWORD PTR ch$[rbp], eax
  00035	c7 45 44 00 00
	00 00		 mov	 DWORD PTR znaki$[rbp], 0
  0003c	c7 45 64 00 00
	00 00		 mov	 DWORD PTR litery$[rbp], 0
  00043	c7 85 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR cyfry$[rbp], 0
  0004d	c7 85 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR wyrazy$[rbp], 0
  00057	c7 85 c4 00 00
	00 00 00 00 00	 mov	 DWORD PTR bZnaki$[rbp], 0
  00061	c7 85 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR samog$[rbp], 0
  0006b	c7 85 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR spolg$[rbp], 0
  00075	c7 85 24 01 00
	00 00 00 00 00	 mov	 DWORD PTR DL$[rbp], 0
  0007f	c7 85 44 01 00
	00 00 00 00 00	 mov	 DWORD PTR ml$[rbp], 0
  00089	c7 85 64 01 00
	00 00 00 00 00	 mov	 DWORD PTR znakiP$[rbp], 0
$LN2@main:

; 11   : 
; 12   : 	while (ch != EOF) {

  00093	83 7d 24 ff	 cmp	 DWORD PTR ch$[rbp], -1
  00097	0f 84 86 02 00
	00		 je	 $LN3@main

; 13   : 		wyraz = 0;

  0009d	c6 85 64 02 00
	00 01		 mov	 BYTE PTR $T2[rbp], 1
  000a4	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR wyraz$[rbp], 0
$LN4@main:

; 14   : 
; 15   : 		while (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z') {

  000ae	83 7d 24 41	 cmp	 DWORD PTR ch$[rbp], 65	; 00000041H
  000b2	7c 06		 jl	 SHORT $LN7@main
  000b4	83 7d 24 5a	 cmp	 DWORD PTR ch$[rbp], 90	; 0000005aH
  000b8	7e 14		 jle	 SHORT $LN6@main
$LN7@main:
  000ba	83 7d 24 61	 cmp	 DWORD PTR ch$[rbp], 97	; 00000061H
  000be	0f 8c 17 01 00
	00		 jl	 $LN5@main
  000c4	83 7d 24 7a	 cmp	 DWORD PTR ch$[rbp], 122	; 0000007aH
  000c8	0f 8f 0d 01 00
	00		 jg	 $LN5@main
$LN6@main:

; 16   : 			litery++;

  000ce	8b 45 64	 mov	 eax, DWORD PTR litery$[rbp]
  000d1	ff c0		 inc	 eax
  000d3	89 45 64	 mov	 DWORD PTR litery$[rbp], eax

; 17   : 			znaki++;

  000d6	8b 45 44	 mov	 eax, DWORD PTR znaki$[rbp]
  000d9	ff c0		 inc	 eax
  000db	89 45 44	 mov	 DWORD PTR znaki$[rbp], eax

; 18   : 
; 19   : 			if (ch == 'a' || ch == 'o' || ch == 'u' || ch == 'e' || ch == 'i' || ch == 'y' || ch == 'A' || ch == 'O' || ch == 'U' || ch == 'E' || ch == 'I' || ch == 'Y') {

  000de	83 7d 24 61	 cmp	 DWORD PTR ch$[rbp], 97	; 00000061H
  000e2	74 42		 je	 SHORT $LN10@main
  000e4	83 7d 24 6f	 cmp	 DWORD PTR ch$[rbp], 111	; 0000006fH
  000e8	74 3c		 je	 SHORT $LN10@main
  000ea	83 7d 24 75	 cmp	 DWORD PTR ch$[rbp], 117	; 00000075H
  000ee	74 36		 je	 SHORT $LN10@main
  000f0	83 7d 24 65	 cmp	 DWORD PTR ch$[rbp], 101	; 00000065H
  000f4	74 30		 je	 SHORT $LN10@main
  000f6	83 7d 24 69	 cmp	 DWORD PTR ch$[rbp], 105	; 00000069H
  000fa	74 2a		 je	 SHORT $LN10@main
  000fc	83 7d 24 79	 cmp	 DWORD PTR ch$[rbp], 121	; 00000079H
  00100	74 24		 je	 SHORT $LN10@main
  00102	83 7d 24 41	 cmp	 DWORD PTR ch$[rbp], 65	; 00000041H
  00106	74 1e		 je	 SHORT $LN10@main
  00108	83 7d 24 4f	 cmp	 DWORD PTR ch$[rbp], 79	; 0000004fH
  0010c	74 18		 je	 SHORT $LN10@main
  0010e	83 7d 24 55	 cmp	 DWORD PTR ch$[rbp], 85	; 00000055H
  00112	74 12		 je	 SHORT $LN10@main
  00114	83 7d 24 45	 cmp	 DWORD PTR ch$[rbp], 69	; 00000045H
  00118	74 0c		 je	 SHORT $LN10@main
  0011a	83 7d 24 49	 cmp	 DWORD PTR ch$[rbp], 73	; 00000049H
  0011e	74 06		 je	 SHORT $LN10@main
  00120	83 7d 24 59	 cmp	 DWORD PTR ch$[rbp], 89	; 00000059H
  00124	75 10		 jne	 SHORT $LN8@main
$LN10@main:

; 20   : 				samog++;

  00126	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR samog$[rbp]
  0012c	ff c0		 inc	 eax
  0012e	89 85 e4 00 00
	00		 mov	 DWORD PTR samog$[rbp], eax

; 21   : 			}
; 22   : 			else {

  00134	eb 0e		 jmp	 SHORT $LN9@main
$LN8@main:

; 23   : 				spolg++;

  00136	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR spolg$[rbp]
  0013c	ff c0		 inc	 eax
  0013e	89 85 04 01 00
	00		 mov	 DWORD PTR spolg$[rbp], eax
$LN9@main:

; 24   : 			}
; 25   : 
; 26   : 			if (ch >= 'A' && ch <= 'Z') {

  00144	83 7d 24 41	 cmp	 DWORD PTR ch$[rbp], 65	; 00000041H
  00148	7c 16		 jl	 SHORT $LN11@main
  0014a	83 7d 24 5a	 cmp	 DWORD PTR ch$[rbp], 90	; 0000005aH
  0014e	7f 10		 jg	 SHORT $LN11@main

; 27   : 				DL++;

  00150	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR DL$[rbp]
  00156	ff c0		 inc	 eax
  00158	89 85 24 01 00
	00		 mov	 DWORD PTR DL$[rbp], eax

; 28   : 			}
; 29   : 			else {

  0015e	eb 0e		 jmp	 SHORT $LN12@main
$LN11@main:

; 30   : 				ml++;

  00160	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR ml$[rbp]
  00166	ff c0		 inc	 eax
  00168	89 85 44 01 00
	00		 mov	 DWORD PTR ml$[rbp], eax
$LN12@main:

; 31   : 			}
; 32   : 
; 33   : 			if ((prevCh == EOF || prevCh == ' ' || prevCh == '\t' || prevCh == '\n' || prevCh == '\v' || prevCh == '\f' || prevCh == '\r') && wyraz == 0)

  0016e	83 7d 04 ff	 cmp	 DWORD PTR prevCh$[rbp], -1
  00172	74 24		 je	 SHORT $LN14@main
  00174	83 7d 04 20	 cmp	 DWORD PTR prevCh$[rbp], 32 ; 00000020H
  00178	74 1e		 je	 SHORT $LN14@main
  0017a	83 7d 04 09	 cmp	 DWORD PTR prevCh$[rbp], 9
  0017e	74 18		 je	 SHORT $LN14@main
  00180	83 7d 04 0a	 cmp	 DWORD PTR prevCh$[rbp], 10
  00184	74 12		 je	 SHORT $LN14@main
  00186	83 7d 04 0b	 cmp	 DWORD PTR prevCh$[rbp], 11
  0018a	74 0c		 je	 SHORT $LN14@main
  0018c	83 7d 04 0c	 cmp	 DWORD PTR prevCh$[rbp], 12
  00190	74 06		 je	 SHORT $LN14@main
  00192	83 7d 04 0d	 cmp	 DWORD PTR prevCh$[rbp], 13
  00196	75 2f		 jne	 SHORT $LN13@main
$LN14@main:
  00198	80 bd 64 02 00
	00 00		 cmp	 BYTE PTR $T2[rbp], 0
  0019f	75 0c		 jne	 SHORT $LN32@main
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:main$rtcName$0
  001a8	e8 00 00 00 00	 call	 _RTC_UninitUse
$LN32@main:
  001ad	83 bd 84 01 00
	00 00		 cmp	 DWORD PTR wyraz$[rbp], 0
  001b4	75 11		 jne	 SHORT $LN13@main

; 34   : 				wyraz = 1;

  001b6	c6 85 64 02 00
	00 01		 mov	 BYTE PTR $T2[rbp], 1
  001bd	c7 85 84 01 00
	00 01 00 00 00	 mov	 DWORD PTR wyraz$[rbp], 1
$LN13@main:

; 35   : 
; 36   : 			prevCh = ch;

  001c7	8b 45 24	 mov	 eax, DWORD PTR ch$[rbp]
  001ca	89 45 04	 mov	 DWORD PTR prevCh$[rbp], eax

; 37   : 			ch = getchar();

  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getchar
  001d3	89 45 24	 mov	 DWORD PTR ch$[rbp], eax

; 38   : 		}

  001d6	e9 d3 fe ff ff	 jmp	 $LN4@main
$LN5@main:

; 39   : 
; 40   : 		if (ch >= '0' && ch <= '9') {

  001db	83 7d 24 30	 cmp	 DWORD PTR ch$[rbp], 48	; 00000030H
  001df	7c 19		 jl	 SHORT $LN15@main
  001e1	83 7d 24 39	 cmp	 DWORD PTR ch$[rbp], 57	; 00000039H
  001e5	7f 13		 jg	 SHORT $LN15@main

; 41   : 			cyfry++;

  001e7	8b 85 84 00 00
	00		 mov	 eax, DWORD PTR cyfry$[rbp]
  001ed	ff c0		 inc	 eax
  001ef	89 85 84 00 00
	00		 mov	 DWORD PTR cyfry$[rbp], eax
  001f5	e9 0d 01 00 00	 jmp	 $LN16@main
$LN15@main:

; 42   : 		}
; 43   : 		else if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\v' || ch == '\f' || ch == '\r') {

  001fa	83 7d 24 20	 cmp	 DWORD PTR ch$[rbp], 32	; 00000020H
  001fe	74 1e		 je	 SHORT $LN19@main
  00200	83 7d 24 09	 cmp	 DWORD PTR ch$[rbp], 9
  00204	74 18		 je	 SHORT $LN19@main
  00206	83 7d 24 0a	 cmp	 DWORD PTR ch$[rbp], 10
  0020a	74 12		 je	 SHORT $LN19@main
  0020c	83 7d 24 0b	 cmp	 DWORD PTR ch$[rbp], 11
  00210	74 0c		 je	 SHORT $LN19@main
  00212	83 7d 24 0c	 cmp	 DWORD PTR ch$[rbp], 12
  00216	74 06		 je	 SHORT $LN19@main
  00218	83 7d 24 0d	 cmp	 DWORD PTR ch$[rbp], 13
  0021c	75 68		 jne	 SHORT $LN17@main
$LN19@main:

; 44   : 			bZnaki++;

  0021e	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR bZnaki$[rbp]
  00224	ff c0		 inc	 eax
  00226	89 85 c4 00 00
	00		 mov	 DWORD PTR bZnaki$[rbp], eax

; 45   : 
; 46   : 			if ((prevCh >= 'A' && prevCh <= 'Z' || prevCh >= 'a' && prevCh <= 'z') && wyraz == 1) {

  0022c	83 7d 04 41	 cmp	 DWORD PTR prevCh$[rbp], 65 ; 00000041H
  00230	7c 06		 jl	 SHORT $LN22@main
  00232	83 7d 04 5a	 cmp	 DWORD PTR prevCh$[rbp], 90 ; 0000005aH
  00236	7e 0c		 jle	 SHORT $LN21@main
$LN22@main:
  00238	83 7d 04 61	 cmp	 DWORD PTR prevCh$[rbp], 97 ; 00000061H
  0023c	7c 43		 jl	 SHORT $LN20@main
  0023e	83 7d 04 7a	 cmp	 DWORD PTR prevCh$[rbp], 122 ; 0000007aH
  00242	7f 3d		 jg	 SHORT $LN20@main
$LN21@main:
  00244	80 bd 64 02 00
	00 00		 cmp	 BYTE PTR $T2[rbp], 0
  0024b	75 0c		 jne	 SHORT $LN33@main
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:main$rtcName$0
  00254	e8 00 00 00 00	 call	 _RTC_UninitUse
$LN33@main:
  00259	83 bd 84 01 00
	00 01		 cmp	 DWORD PTR wyraz$[rbp], 1
  00260	75 1f		 jne	 SHORT $LN20@main

; 47   : 				wyraz = 0;

  00262	c6 85 64 02 00
	00 01		 mov	 BYTE PTR $T2[rbp], 1
  00269	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR wyraz$[rbp], 0

; 48   : 				wyrazy++;

  00273	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR wyrazy$[rbp]
  00279	ff c0		 inc	 eax
  0027b	89 85 a4 00 00
	00		 mov	 DWORD PTR wyrazy$[rbp], eax
$LN20@main:

; 49   : 			}
; 50   : 		}

  00281	e9 81 00 00 00	 jmp	 $LN18@main
$LN17@main:

; 51   : 		else if (ch == ',' || ch == '.' || ch == ':' || ch == '!' || ch == '?') {

  00286	83 7d 24 2c	 cmp	 DWORD PTR ch$[rbp], 44	; 0000002cH
  0028a	74 18		 je	 SHORT $LN24@main
  0028c	83 7d 24 2e	 cmp	 DWORD PTR ch$[rbp], 46	; 0000002eH
  00290	74 12		 je	 SHORT $LN24@main
  00292	83 7d 24 3a	 cmp	 DWORD PTR ch$[rbp], 58	; 0000003aH
  00296	74 0c		 je	 SHORT $LN24@main
  00298	83 7d 24 21	 cmp	 DWORD PTR ch$[rbp], 33	; 00000021H
  0029c	74 06		 je	 SHORT $LN24@main
  0029e	83 7d 24 3f	 cmp	 DWORD PTR ch$[rbp], 63	; 0000003fH
  002a2	75 63		 jne	 SHORT $LN23@main
$LN24@main:

; 52   : 			znakiP++;

  002a4	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR znakiP$[rbp]
  002aa	ff c0		 inc	 eax
  002ac	89 85 64 01 00
	00		 mov	 DWORD PTR znakiP$[rbp], eax

; 53   : 
; 54   : 			if ((prevCh >= 'A' && prevCh <= 'Z' || prevCh >= 'a' && prevCh <= 'z') && wyraz == 1) {

  002b2	83 7d 04 41	 cmp	 DWORD PTR prevCh$[rbp], 65 ; 00000041H
  002b6	7c 06		 jl	 SHORT $LN27@main
  002b8	83 7d 04 5a	 cmp	 DWORD PTR prevCh$[rbp], 90 ; 0000005aH
  002bc	7e 0c		 jle	 SHORT $LN26@main
$LN27@main:
  002be	83 7d 04 61	 cmp	 DWORD PTR prevCh$[rbp], 97 ; 00000061H
  002c2	7c 43		 jl	 SHORT $LN25@main
  002c4	83 7d 04 7a	 cmp	 DWORD PTR prevCh$[rbp], 122 ; 0000007aH
  002c8	7f 3d		 jg	 SHORT $LN25@main
$LN26@main:
  002ca	80 bd 64 02 00
	00 00		 cmp	 BYTE PTR $T2[rbp], 0
  002d1	75 0c		 jne	 SHORT $LN34@main
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:main$rtcName$0
  002da	e8 00 00 00 00	 call	 _RTC_UninitUse
$LN34@main:
  002df	83 bd 84 01 00
	00 01		 cmp	 DWORD PTR wyraz$[rbp], 1
  002e6	75 1f		 jne	 SHORT $LN25@main

; 55   : 				wyraz = 0;

  002e8	c6 85 64 02 00
	00 01		 mov	 BYTE PTR $T2[rbp], 1
  002ef	c7 85 84 01 00
	00 00 00 00 00	 mov	 DWORD PTR wyraz$[rbp], 0

; 56   : 				wyrazy++;

  002f9	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR wyrazy$[rbp]
  002ff	ff c0		 inc	 eax
  00301	89 85 a4 00 00
	00		 mov	 DWORD PTR wyrazy$[rbp], eax
$LN25@main:
$LN23@main:
$LN18@main:
$LN16@main:

; 57   : 			}
; 58   : 		}
; 59   : 
; 60   : 		prevCh = ch;

  00307	8b 45 24	 mov	 eax, DWORD PTR ch$[rbp]
  0030a	89 45 04	 mov	 DWORD PTR prevCh$[rbp], eax

; 61   : 		ch = getchar();

  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getchar
  00313	89 45 24	 mov	 DWORD PTR ch$[rbp], eax

; 62   : 		znaki++;

  00316	8b 45 44	 mov	 eax, DWORD PTR znaki$[rbp]
  00319	ff c0		 inc	 eax
  0031b	89 45 44	 mov	 DWORD PTR znaki$[rbp], eax

; 63   : 	}

  0031e	e9 70 fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 64   : 
; 65   : 	if ((prevCh >= 'A' && prevCh <= 'Z' || prevCh >= 'a' && prevCh <= 'z') && wyraz == 1) {

  00323	83 7d 04 41	 cmp	 DWORD PTR prevCh$[rbp], 65 ; 00000041H
  00327	7c 06		 jl	 SHORT $LN30@main
  00329	83 7d 04 5a	 cmp	 DWORD PTR prevCh$[rbp], 90 ; 0000005aH
  0032d	7e 0c		 jle	 SHORT $LN29@main
$LN30@main:
  0032f	83 7d 04 61	 cmp	 DWORD PTR prevCh$[rbp], 97 ; 00000061H
  00333	7c 32		 jl	 SHORT $LN28@main
  00335	83 7d 04 7a	 cmp	 DWORD PTR prevCh$[rbp], 122 ; 0000007aH
  00339	7f 2c		 jg	 SHORT $LN28@main
$LN29@main:
  0033b	80 bd 64 02 00
	00 00		 cmp	 BYTE PTR $T2[rbp], 0
  00342	75 0c		 jne	 SHORT $LN35@main
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:main$rtcName$0
  0034b	e8 00 00 00 00	 call	 _RTC_UninitUse
$LN35@main:
  00350	83 bd 84 01 00
	00 01		 cmp	 DWORD PTR wyraz$[rbp], 1
  00357	75 0e		 jne	 SHORT $LN28@main

; 66   : 		wyrazy++;

  00359	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR wyrazy$[rbp]
  0035f	ff c0		 inc	 eax
  00361	89 85 a4 00 00
	00		 mov	 DWORD PTR wyrazy$[rbp], eax
$LN28@main:

; 67   : 	}
; 68   : 
; 69   : 	printf("znakow: %d\nliter: %d\ncyfr: %d\nwyrazow: %d\nbialych znakow: %d\nsamoglosek: %d\nspolglosek: %d\nduzych liter: %d\nmalych liter: %d\nznakow przestankowych: %d\n", znaki, litery, cyfry, wyrazy, bZnaki, samog, spolg, DL, ml, znakiP);

  00367	8b 85 64 01 00
	00		 mov	 eax, DWORD PTR znakiP$[rbp]
  0036d	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00371	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR ml$[rbp]
  00377	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0037b	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR DL$[rbp]
  00381	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00385	8b 85 04 01 00
	00		 mov	 eax, DWORD PTR spolg$[rbp]
  0038b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0038f	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR samog$[rbp]
  00395	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00399	8b 85 c4 00 00
	00		 mov	 eax, DWORD PTR bZnaki$[rbp]
  0039f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003a3	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR wyrazy$[rbp]
  003a9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003ad	44 8b 8d 84 00
	00 00		 mov	 r9d, DWORD PTR cyfry$[rbp]
  003b4	44 8b 45 64	 mov	 r8d, DWORD PTR litery$[rbp]
  003b8	8b 55 44	 mov	 edx, DWORD PTR znaki$[rbp]
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0JI@GFKDDBPG@znakow?3?5?$CFd?6liter?3?5?$CFd?6cyfr?3?5?$CFd?6wy@
  003c2	e8 00 00 00 00	 call	 printf

; 70   : 
; 71   : 	return 0;

  003c7	33 c0		 xor	 eax, eax

; 72   : }

  003c9	48 8d a5 88 02
	00 00		 lea	 rsp, QWORD PTR [rbp+648]
  003d0	5f		 pop	 rdi
  003d1	5d		 pop	 rbp
  003d2	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 4
_ArgList$ = 40
__$ArrayPad$ = 248
_Format$ = 288
printf	PROC						; COMDAT

; 950  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8d 6c 24 20	 lea	 rbp, QWORD PTR [rsp+32]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 4a 00 00 00	 mov	 ecx, 74			; 0000004aH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR [rsp+328]
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c5	 xor	 rax, rbp
  00043	48 89 85 f8 00
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 951  :     int _Result;
; 952  :     va_list _ArgList;
; 953  :     __crt_va_start(_ArgList, _Format);

  0004a	e8 00 00 00 00	 call	 ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
  0004f	48 8d 85 28 01
	00 00		 lea	 rax, QWORD PTR _Format$[rbp+8]
  00056	48 89 45 28	 mov	 QWORD PTR _ArgList$[rbp], rax

; 954  :     _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00065	4c 8b 4d 28	 mov	 r9, QWORD PTR _ArgList$[rbp]
  00069	45 33 c0	 xor	 r8d, r8d
  0006c	48 8b 95 20 01
	00 00		 mov	 rdx, QWORD PTR _Format$[rbp]
  00073	48 8b c8	 mov	 rcx, rax
  00076	e8 00 00 00 00	 call	 _vfprintf_l
  0007b	89 45 04	 mov	 DWORD PTR _Result$[rbp], eax

; 955  :     __crt_va_end(_ArgList);

  0007e	48 c7 45 28 00
	00 00 00	 mov	 QWORD PTR _ArgList$[rbp], 0

; 956  :     return _Result;

  00086	8b 45 04	 mov	 eax, DWORD PTR _Result$[rbp]

; 957  : }

  00089	8b f8		 mov	 edi, eax
  0008b	48 8d 4d e0	 lea	 rcx, QWORD PTR [rbp-32]
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printf$rtcFrameData
  00096	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0009b	8b c7		 mov	 eax, edi
  0009d	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000a4	48 33 cd	 xor	 rcx, rbp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 8d a5 08 01
	00 00		 lea	 rsp, QWORD PTR [rbp+264]
  000b3	5f		 pop	 rdi
  000b4	5d		 pop	 rbp
  000b5	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>, COMDAT

; 144  :         {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  0001c	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  00023	5f		 pop	 rdi
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QEBD@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<char const * __ptr64 const>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 224
_Format$ = 232
_Locale$ = 240
_ArgList$ = 248
_vfprintf_l PROC					; COMDAT

; 638  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001d	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]
  00022	48 8b fc	 mov	 rdi, rsp
  00025	b9 3e 00 00 00	 mov	 ecx, 62			; 0000003eH
  0002a	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002f	f3 ab		 rep stosd
  00031	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR [rsp+280]

; 639  :     return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00039	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0003e	48 8b 8d f8 00
	00 00		 mov	 rcx, QWORD PTR _ArgList$[rbp]
  00045	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004a	4c 8b 8d f0 00
	00 00		 mov	 r9, QWORD PTR _Locale$[rbp]
  00051	4c 8b 85 e8 00
	00 00		 mov	 r8, QWORD PTR _Format$[rbp]
  00058	48 8b 95 e0 00
	00 00		 mov	 rdx, QWORD PTR _Stream$[rbp]
  0005f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 640  : }

  00068	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0006f	5f		 pop	 rdi
  00070	5d		 pop	 rbp
  00071	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 73   : {

$LN3:
  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000a	48 8b ec	 mov	 rbp, rsp
  0000d	48 8b fc	 mov	 rdi, rsp
  00010	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00023	48 8d a5 c8 00
	00 00		 lea	 rsp, QWORD PTR [rbp+200]
  0002a	5f		 pop	 rdi
  0002b	5d		 pop	 rbp
  0002c	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
